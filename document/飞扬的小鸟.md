[EasyX Graphics Library for C++](https://easyx.cn/)EasyX官网

在文档部分可查询其函数的使用方法

EasyX是一个C++编写的函数库，可以用来实现图片的显示和声音的读取  很适合初学者进行小游戏的开发 
每个编程语言都有入口函数 不管多复杂的程序总是会有一行代码被首先执行
每个编程语言都有固定的入口格式 

使用EasyX库前需要在项目属性——参数——链接中添加-leasyx 否则会报错

### 静态菜单

#### 绘制矩形rectangle

![image-20250821171347692](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250821171347692.png)





#### 设置填充颜色setfillcolor

![image-20250821171729402](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250821171729402.png)



#### 绘制填充矩形fillrectangle

这个函数用于画有边框的填充矩形。

```cpp
void fillrectangle(
	int left,
	int top,
	int right,
	int bottom
);
```

参数

left

矩形左部 x 坐标。

top

矩形顶部 y 坐标。

right

矩形右部 x 坐标。

bottom

矩形底部 y 坐标。



#### drawtext

```c++
int drawtext(
	LPCTSTR str,
	RECT* pRect, //RECT*为结构体指针
	UINT uFormat //uFormat是文字输出格式，文档中有
);
```

下面是我使用到的uFormat部分格式：

| DT_CENTER     | 文字水平居中。                                    |
| ------------- | ------------------------------------------------- |
| DT_SINGLELINE | 使文字显示在一行。回车和换行符都无效。            |
| DT_VCENTER    | 文字垂直居中。仅当和 DT_SINGLELINE 一起使用时有效 |

e.g.

```c++
	char *str = "开始游戏";
	RECT value = {200,120,450,50};//里面参数是我提前绘制好的方框
	drawtext(str,&value,DT_CENTER|DT_SINGLELINE|DT_VCENTER);
```



#### 代码

```c++
#include <iostream>
#include <graphics.h> //EasyX的头文件 (图形界面和基本图形绘制头文件)
//EasyX是一个C++编写的函数库，可以用来实现图片的显示和声音的读取  很适合初学者进行小游戏的开发 
//每个编程语言都有入口函数 不管多复杂的程序总是会有一行代码被首先执行
//每个编程语言都有固定的入口格式 
int main(int argc, char** argv) {
	
	char *str = "开始游戏";
	char *game_opt = "游戏设置";
	char *game_help = "游戏帮助";
	char *game_exit = "游戏退出";
	RECT rect_value = {200,120,450,170};
	RECT rect_game_opt = {200,170,450,230};
	RECT rect_game_help = {200,220,450,280};
	RECT rect_game_exit = {200,270,450,330};
	initgraph(800,600); //创建窗口 使用EasyX库前需要在项目属性——参数——链接中添加-leasyx 否则会报错
//	rectangle(200,120,450,170);	//绘制空白矩形 (left,top,right,bottom) 
	setfillcolor(BLUE);	//函数用于设置你要填充的颜色 
	
	fillrectangle(200,120,450,170);//绘制填充矩形 
	drawtext(str,&rect_value,DT_CENTER|DT_SINGLELINE|DT_VCENTER);
	fillrectangle(200,170,450,230);//x轴不变，y轴在上一个框的基础上加50
	drawtext(game_opt,&rect_game_opt,DT_CENTER|DT_SINGLELINE|DT_VCENTER);
	fillrectangle(200,220,450,280);
	drawtext(game_help,&rect_game_help,DT_CENTER|DT_SINGLELINE|DT_VCENTER);
	fillrectangle(200,270,450,330); 
		drawtext(game_exit,&rect_game_exit,DT_CENTER|DT_SINGLELINE|DT_VCENTER);
    
    
	while(1);
	return 0;
}
```

### ——————————————

### 动态菜单

kbhit() 用户敲击键盘，函数返回1  

GetAsyncKeyState 实时、异步（每时每刻都在查询，不同于同步只有消息队列到了才查询）地查询键盘或鼠标按钮的瞬时状态

遭遇问题：在图形窗口中按向下键无效的问题？

因为**kbhit() 函数只检测控制台窗口的输入，而不检测图形窗口的输入**

原先我这么写就会有问题 没有延时，会从开始游戏直接跳到游戏帮助，检测间隔太短了

```C++
	while(1)
	{
		if(kbhit())//如果用户有敲击键盘，那么这个函数就返回1
		{
			if(GetAsyncKeyState(VK_DOWN)) //向下键被按下了 
			{
				switch(menuSelect)
				{
					//由于我们默认为开始游戏，所以第一次按下应该跳转到游戏设置 
					case menu_game_start:
						setfillcolor(BLUE); //恢复为蓝色  
						fillrectangle(200,120,450,170);//绘制填充矩形 
						drawtext(str,&rect_value,DT_CENTER|DT_SINGLELINE|DT_VCENTER);//字体会被覆盖，还得重新再写一遍 
						
						setfillcolor(RED);
						fillrectangle(200,170,450,230);
						drawtext(game_opt,&rect_game_opt,DT_CENTER|DT_SINGLELINE|DT_VCENTER);//字体会被覆盖，还得重新再写一遍 
						menuSelect = menu_game_opt; 
						break;
					
					case menu_game_opt:	
						setfillcolor(BLUE); //恢复为蓝色  
						fillrectangle(200,170,450,230);//绘制填充矩形 
						drawtext(game_opt,&rect_game_opt,DT_CENTER|DT_SINGLELINE|DT_VCENTER);//字体会被覆盖，还得重新再写一遍 
							
						setfillcolor(RED);
						fillrectangle(200,220,450,280);
						drawtext(game_help,&rect_game_help,DT_CENTER|DT_SINGLELINE|DT_VCENTER);
						menuSelect = menu_game_help; 	
						break;
					
					case menu_game_help:
						break;
						
					case menu_game_exit:
						break;
				}
			}
		}
	}
```

更新后

```C++
#include <iostream>
#include <graphics.h> //EasyX的头文件 (图形界面和基本图形绘制头文件)
#include <windows.h> //GetAsyncKeyState头文件 
//EasyX是一个C++编写的函数库，可以用来实现图片的显示和声音的读取  很适合初学者进行小游戏的开发 
//每个编程语言都有入口函数 不管多复杂的程序总是会有一行代码被首先执行
//每个编程语言都有固定的入口格式 

#define menu_game_start 0
#define menu_game_opt 1
#define menu_game_help 2
#define menu_game_exit 3
int menuSelect = 0; 

int main(int argc, char** argv) {
	
	char *str = "开始游戏";
	char *game_opt = "游戏设置";
	char *game_help = "游戏帮助";
	char *game_exit = "游戏退出";
	RECT rect_value = {200,120,450,170};
	RECT rect_game_opt = {200,170,450,230};
	RECT rect_game_help = {200,220,450,280};
	RECT rect_game_exit = {200,270,450,330};
	initgraph(800,600); //创建窗口 使用EasyX库前需要在项目属性——参数——链接中添加-leasyx 否则会报错
//	rectangle(200,120,450,170);	//绘制空白矩形 (left,top,right,bottom) 
	setfillcolor(BLUE);	//函数用于设置你要填充的颜色 
	
	fillrectangle(200,120,450,170);//绘制填充矩形 
	drawtext(str,&rect_value,DT_CENTER|DT_SINGLELINE|DT_VCENTER);
	fillrectangle(200,170,450,230);//x轴不变，y轴在上一个框的基础上加50
	drawtext(game_opt,&rect_game_opt,DT_CENTER|DT_SINGLELINE|DT_VCENTER);
	fillrectangle(200,220,450,280);
	drawtext(game_help,&rect_game_help,DT_CENTER|DT_SINGLELINE|DT_VCENTER);
	fillrectangle(200,270,450,330); 
	drawtext(game_exit,&rect_game_exit,DT_CENTER|DT_SINGLELINE|DT_VCENTER);
	
	//开始游戏默认为红色 
	setfillcolor(RED);
	fillrectangle(200,120,450,170);//绘制填充矩形 
	drawtext(str,&rect_value,DT_CENTER|DT_SINGLELINE|DT_VCENTER);//字体会被覆盖，还得重新再写一遍
	 
	//动态菜单最核心的就是键盘捕获，如何捕获键盘上下键
	//kbhit keybord hit  头文件 conio.h 
	//GetAsyncKeyState 实时、异步（每时每刻都在查询，不同于同步只有消息队列到了才查询）地查询键盘或鼠标按钮的瞬时状态
	while(1)
	{
		Sleep(100); //防止跳转过快 
		if(GetAsyncKeyState(VK_DOWN)) //向下键被按下了 
		{
			switch(menuSelect)
			{
				//由于我们默认为开始游戏，所以第一次按下应该跳转到游戏设置 
				case menu_game_start:
					setfillcolor(BLUE); //恢复为蓝色  
					fillrectangle(200,120,450,170);//绘制填充矩形 
					drawtext(str,&rect_value,DT_CENTER|DT_SINGLELINE|DT_VCENTER);//字体会被覆盖，还得重新再写一遍 
						
					setfillcolor(RED);
					fillrectangle(200,170,450,230);
					drawtext(game_opt,&rect_game_opt,DT_CENTER|DT_SINGLELINE|DT_VCENTER);//字体会被覆盖，还得重新再写一遍 
					menuSelect = menu_game_opt; 
					break;
					
				case menu_game_opt:	
					setfillcolor(BLUE); //恢复为蓝色  
					fillrectangle(200,170,450,230);//绘制填充矩形 
					drawtext(game_opt,&rect_game_opt,DT_CENTER|DT_SINGLELINE|DT_VCENTER);//字体会被覆盖，还得重新再写一遍 
							
					setfillcolor(RED);
					fillrectangle(200,220,450,280);
					drawtext(game_help,&rect_game_help,DT_CENTER|DT_SINGLELINE|DT_VCENTER);
					menuSelect = menu_game_help; 	
					break;	
					
				case menu_game_help:
					setfillcolor(BLUE);
					fillrectangle(200,220,450,280);
					drawtext(game_help,&rect_game_help,DT_CENTER|DT_SINGLELINE|DT_VCENTER);
					
					setfillcolor(RED);
					fillrectangle(200,270,450,330); 
					drawtext(game_exit,&rect_game_exit,DT_CENTER|DT_SINGLELINE|DT_VCENTER);
					menuSelect = menu_game_exit;
					break;
						
				case menu_game_exit:
					setfillcolor(BLUE);
					fillrectangle(200,270,450,330); 
					drawtext(game_exit,&rect_game_exit,DT_CENTER|DT_SINGLELINE|DT_VCENTER);
					
					setfillcolor(RED);
					fillrectangle(200,120,450,170);//绘制填充矩形 
					drawtext(str,&rect_value,DT_CENTER|DT_SINGLELINE|DT_VCENTER);//字体会被覆盖，还得重新再写一遍 
					menuSelect = menu_game_start;
					break;	
			}
		}
	}
	return 0;
}
```

VK_UP逻辑跟VK_Down差不多，只需要稍微调整一下就行

还有个回车结束游戏菜单的逻辑

```c++
	if(GetAsyncKeyState(VK_RETURN))
		{
			switch(menuSelect)
			{
				case menu_game_start:
				
					return;	 //showMenu()函数结束
					break; 
				case menu_game_opt:
					break;
				case menu_game_help:
					break;
				case menu_game_exit:
					break;
			}
		}
```



### ——————————————

### 正式游戏部分



将图片显示到窗口中

```c++
	IMAGE backImg; //用来保存图片的变量 
	loadimage(&backImg,"./img/back12.jpg");
```



#### 在图形窗口中读取图像loadimage

这个函数用于从文件中读取图像。 窗口左上角为0,0

```cpp
// 从图片文件获取图像(bmp/gif/jpg/png/tif/emf/wmf/ico)
void loadimage(
	IMAGE* pDstImg,			// 保存图像的 IMAGE 对象指针
	LPCTSTR pImgFile,		// 图片文件名
	int nWidth = 0,			// 图片的拉伸宽度
	int nHeight = 0,		// 图片的拉伸高度
	bool bResize = false	// 是否调整 IMAGE 的大小以适应图片
);
// 从资源文件获取图像(bmp/gif/jpg/png/tif/emf/wmf/ico)
void loadimage(
	IMAGE* pDstImg,			// 保存图像的 IMAGE 对象指针
	LPCTSTR pResType,		// 资源类型
	LPCTSTR pResName,		// 资源名称
	int nWidth = 0,			// 图片的拉伸宽度
	int nHeight = 0,		// 图片的拉伸高度
	bool bResize = false	// 是否调整 IMAGE 的大小以适应图片
);
```

参数

pDstImg

保存图像的 IMAGE 对象指针。如果为 NULL，表示图片将读取至绘图窗口。

pImgFile

图片文件名。支持 bmp / gif / jpg / png / tif / emf / wmf / ico 格式的图片。gif 格式的图片仅加载第一帧；gif 与 png 均不支持透明。

nWidth

图片的拉伸宽度。加载图片后，会拉伸至该宽度。如果为 0，表示使用原图的宽度。

nHeight

图片的拉伸高度。加载图片后，会拉伸至该高度。如果为 0，表示使用原图的高度。

bResize

是否调整 IMAGE 的大小以适应图片。

pResType

图片资源类型。

pResName

图片资源名称。

#### 在图形窗口中绘制图像putimage

这个函数的几个重载用于在当前设备上绘制指定图像。

```cpp
// 绘制图像
void putimage(
	int dstX,				// 绘制位置的 x 坐标
	int dstY,				// 绘制位置的 y 坐标
	IMAGE *pSrcImg,			// 要绘制的 IMAGE 对象指针
	DWORD dwRop = SRCCOPY	// 三元光栅操作码
);

// 绘制图像(指定宽高和起始位置)
void putimage(
	int dstX,				// 绘制位置的 x 坐标
	int dstY,				// 绘制位置的 y 坐标
	int dstWidth,			// 绘制的宽度
	int dstHeight,			// 绘制的高度
	IMAGE *pSrcImg,			// 要绘制的 IMAGE 对象指针
	int srcX,				// 绘制内容在 IMAGE 对象中的左上角 x 坐标
	int srcY,				// 绘制内容在 IMAGE 对象中的左上角 y 坐标
	DWORD dwRop = SRCCOPY	// 三元光栅操作码
);
```

#### 图片拉伸

调不了，不会调.....



#### 图片去除白边

我们添加完小鸟图片发现是有白色边框的，我们要去掉，怎么搞？

![image-20250822171054820](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250822171054820.png)

就要用到我们上面的三元光栅操作码了，我们这里只贴出我需要用到的，其余在帮助文档中

| NOTSRCERASE | 目标图像 = NOT (目标图像 OR 源图像) |
| ----------- | ----------------------------------- |
| SRCINVERT   | 目标图像 = 目标图像 XOR 源图像      |

![image-20250822172843261](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250822172843261.png)

首先是使用NOTSRCERASE对bird1_1进行**反色**，即变为白底黑色小鸟边，作为前景

然后使用SRCINVERT异或清除掉前景的白底，然后只剩小鸟



#### 小鸟运动

原理就是 putimage内的x轴和y轴在动态变化

```C++
	putimage(birdX,birdY,&birdBkImg,NOTSRCERASE);
	putimage(birdX,birdY,&birdImg,SRCINVERT);
```

那我们把代码放入死循环中

小鸟下落？ ————> 每次循环Y+=3

小鸟在背景中没有下落过程并且长影？  ————> 循环太快，加个睡眠时间Sleep()

小鸟在背景中有下落过程了，但是还有长影？ ————> 刷新背景，将	`putimage(0,0,&backImg);`也放入循环中

```c++
	while(1)
	{
		putimage(0,0,&backImg);
		putimage(birdX,birdY,&birdBkImg,NOTSRCERASE);
		putimage(birdX,birdY,&birdImg,SRCINVERT);
		birdY+=3;
		if(birdY > 800) //超出边界
		{
			birdY = 0; 
		}
		Sleep(50);	
	}
```



水管也是一样，首先先用前景和背景处理掉白边的问题

水管是从右到左，所以是X坐标-=3



偶尔闪烁？

利用EasyX带的图片缓冲机制解决

#### BeginBatchDraw

这个函数用于开始批量绘图。执行后，任何绘图操作都将暂时不输出到绘图窗口上，直到执行 FlushBatchDraw 或 EndBatchDraw 才将之前的绘图输出。

```cpp
void BeginBatchDraw();
```

#### EndBatchDraw

这个函数用于结束批量绘制，并执行未完成的绘制任务。

```cpp
// 结束批量绘制，并执行未完成的绘制任务
void EndBatchDraw();
```

```C++
	while(1)
	{	
		BeginBatchDraw();
		putimage(0,0,&backImg);
		putimage(birdX,birdY,&birdBkImg,NOTSRCERASE);
		putimage(birdX,birdY,&birdImg,SRCINVERT);
		putimage(pipUpX,pipUpY,&pipUpBkImg,NOTSRCERASE);
		putimage(pipUpX,pipUpY,&pipUpImg,SRCINVERT);
		EndBatchDraw();
		birdY+=3;
		pipUpX-=3;
		if(birdY > 800) //超出边界
		{
			birdY = 0; 
		}
		Sleep(50);	
	}
```





#### 按下空格后跳跃

```c++
 	bool  spaceKeyWasPressed = false; // 记录空格键上次状态
   	//空格键跳跃
    if(GetAsyncKeyState(VK_SPACE) && !spaceKeyWasPressed && !gamePause)  
    {
        birdY -= 50;
        spaceKeyWasPressed= true;
    }
    else if(!GetAsyncKeyState(VK_SPACE))
    {
        spaceKeyWasPressed= false;
    }
```



#### P键暂停

原理是让

```c++
		putimage(0,0,&backImg);
		putimage(birdX,birdY,&birdBkImg,NOTSRCERASE);
		putimage(birdX,birdY,&birdImg,SRCINVERT);
		putimage(pipUpX,pipUpY,&pipUpBkImg,NOTSRCERASE);
		putimage(pipUpX,pipUpY,&pipUpImg,SRCINVERT);
		EndBatchDraw();
		birdY+=3;
		pipUpX-=3;
```

暂停运行

代码如下

```c++
		bool gamePause = false;   // 记录游戏是否暂停
		bool pKeyWasPressed = false;     // 记录P键上次状态
		//P键暂停
		if(GetAsyncKeyState('P') && !pKeyWasPressed)  
		{
			gamePause = !gamePause;
			pKeyWasPressed = true;
			if (gamePause)
            {
                printf("游戏已暂停\n"); 
            }
            else
            {
               printf("游戏已继续\n");
            }
		}
		else if(!GetAsyncKeyState('P'))
		{
			pKeyWasPressed = false;
		}
```

这里的	pKeyWasPressed    和 spaceKeyWasPressed 、gamePause都是要纪录在main函数而非我们的死循环（游戏主体）中。因为要纪录的是按键上次的状态，不能让死循环一直刷新



#### 小鸟与水管碰撞检测

原理就是小鸟左上角的(x,y)与水管左上角的(x,y)相减的绝对值小于小鸟的半径就认为碰撞

当然这是不够准确的。。。

![image-20250822192904596](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250822192904596.png)

```c++
	if(abs(birdX-pipUpX) < 7 || abs(birdY-pipUpY) < 7)
		{
			printf("小鸟与水管发生相撞\n");
			gameOver = true;	
		} 
```

但这样精度差的太多了......而且bug还蛮多的

决定采用经典的矩形碰撞检测

##### 碰撞检测原理

矩形碰撞检测函数 通过检查两个矩形是否重叠来判断是否发生碰撞：

1. **右边缘超过左边缘**: `birdX + birdWidth >= pipUpX`
   - 小鸟的右边缘是否在水管的左边缘右侧
2. **左边缘超过右边缘**: `birdX <= pipUpX + pipWidth`
   - 小鸟的左边缘是否在水管的右边缘左侧
3. **下边缘超过上边缘**: `birdY + birdHeight >= pipUpY`
   - 小鸟的下边缘是否在水管的上边缘下方  （水管在屏幕下方的情况）
4. **上边缘超过下边缘**: `birdY <= pipUpY + pipHeight`
   - 小鸟的上边缘是否在水管的下边缘上方  （水管在屏幕上方的情况）

##### 参数说明

**对于小鸟 (bird)**

- **birdX**: 小鸟在屏幕中所处位置左上角的 X 坐标（水平位置）
- **birdY**: 小鸟在屏幕中所处位置左上角的 Y 坐标（垂直位置）
- **birdWidth**: 小鸟图像的宽度（像素）
- **birdHeight**: 小鸟图像的高度（像素）

**对于水管 (pipUp)**

- **pipUpX**: 水管在屏幕中所处位置左上角的 X 坐标（水平位置）
- **pipUpY**: 水管在屏幕中所处位置左上角的 Y 坐标（垂直位置）
- **pipWidth**: 水管图像的宽度（像素）
- **pipHeight**: 水管图像的高度（像素）









#### 背景音乐

 使用winmm.lib多媒体开发库 需要加入#pragma comment(lib,"winmm.lib") 

```c++
	//加入音乐前要在项目属性——参数——链接中添加-lwinmm 
	mciSendString("open sound/bgm1.mp3 alias bgm",NULL,0,NULL);
	mciSendString("play bgm from 0",NULL,0,NULL);
```

第一句:

`sound/bgm1.mp3`: 这是要打开的文件路径     `alias` 是“别名”,这里我们给这个打开的文件起了一个简短的别名 `bgm`    

第一个NULL是  返回字符串缓冲区 ，用于接收命令执行后可能返回的信息（比如播放状态、错误信息等），这里设置为 `NULL`，表示：“我不关心命令执行后返回什么信息，我只要执行命令就行”。如果你需要获取信息（例如，检查文件是否成功打开），就需要在这里传入一个足够大的字符数组

第二个参数0是缓冲区的大小，没有提供缓冲区

第三个参数是 用于指定一个窗口来接收命令执行完成时发出的通知消息（比如用窗口函数来接收“播放完毕”的消息），设置为 `NULL` 表示：“我不需要接收通知消息，命令发送后就不用管了”。

第二句：

`"play bgm from 0"` `   0` 表示从文件的最开头开始播放。如果你想从第 30 秒开始，可以写成 `from 30000` (因为单位是毫秒)

后续的三个参数同上



- **循环播放**: 如果你想让它循环播放背景音乐，可以把第二行改成：

  ```c
  mciSendString("play bgm from 0 repeat", NULL, 0, NULL);
  ```

  `repeat` 参数表示循环重复播放。

- **关闭音乐**: 当程序结束，或者你想切换音乐时，别忘记关闭设备，释放资源：

  ```C
  mciSendString("close bgm", NULL, 0, NULL);
  ```







#### 显示金币

![image-20250822195828677](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250822195828677.png)

它是一帧一帧的图片，我们要用putimage定位一下

```C++
// 绘制图像(指定宽高和起始位置)
void putimage(
	int dstX,				// 绘制位置的 x 坐标
	int dstY,				// 绘制位置的 y 坐标
	int dstWidth,			// 绘制的宽度
	int dstHeight,			// 绘制的高度
	IMAGE *pSrcImg,			// 要绘制的 IMAGE 对象指针
	int srcX,				// 绘制内容在 IMAGE 对象中的左上角 x 坐标
	int srcY,				// 绘制内容在 IMAGE 对象中的左上角 y 坐标
	DWORD dwRop = SRCCOPY	// 三元光栅操作码
);
```

前两个参数就是金币的位置，再下去两个就是金币的大小，最后srcX和srcY是你要从这张图片的哪个位置截取(要注意图片的第一行对应的Y坐标是0，X坐标也是0)

所以前景其实是第10行，背景是第9行

```C++
putimage(x,y,COIN_WIDTH,COIN_HEIGHT,&aniImg,(0+index)*COIN_WIDTH,9*COIN_HEIGHT,SRCAND);//前景
putimage(x,y,COIN_WIDTH,COIN_HEIGHT,&aniImg,(0+index)*COIN_WIDTH,8*COIN_HEIGHT,SRCPAINT);//背景
```



#### 管道随机位置出现

```c
#include <time.h>
#include <stdlib.h>

#define pipWidth 140
#define pipHeight  600
#define PIPE_GAP 250  // 管道之间的间隙
#define MAX_PIPES 5   // 最大管道数量
// 管道结构体
typedef struct {
    int x;
    int upY;
    int downY;
    bool passed; // 是否已被小鸟通过
} Pipe;

Pipe pipes[MAX_PIPES]; // 使用数组存储管道
int pipeCount = 0;     // 当前管道数量

void generatePipes()
{
	pipeCount = 3; //初始生成三对管道
	for(int i = 0; i < pipeCount; i++) 
	{
        int gapPosition = (rand() % 500) + 100;  
        
        pipes[i].x = 900 + i * 400; // 每对管道间隔400像素
        pipes[i].upY = gapPosition - pipHeight; //上方的管道，可能为负数，是正常的，因为上管道高度要把负数抵消才会延伸出来  
        pipes[i].downY = gapPosition + PIPE_GAP;//下方的管道加PIPE_GAP是为了和上管道隔开一段空间，免得两个管道合在一起了，小鸟过不去 
        pipes[i].passed = false; 
	}
}
//main函数内
int main()
{	
    // 初始化随机数种子
    srand((unsigned int)time(NULL));
    
    	// 生成初始管道
    generatePipes();
    while(1)
    {
        if(gamePause == false)
        {
            	// 绘制所有管道
            for(int i = 0; i < pipeCount; i++) {
                putimage(pipes[i].x, pipes[i].upY, &pipUpBkImg, NOTSRCERASE);
                putimage(pipes[i].x, pipes[i].upY, &pipUpImg, SRCINVERT);
                putimage(pipes[i].x, pipes[i].downY, &pipDownBkImg, NOTSRCERASE);
                putimage(pipes[i].x, pipes[i].downY, &pipDownImg, SRCINVERT);
            }
            	updatePipes();
		}
	}
}
// 更新管道位置
void updatePipes() 
{
    for(int i = 0; i < pipeCount; i++) 
	{
        pipes[i].x -= 3;
        
        // 如果管道移出屏幕左侧，重置到右侧
        if(pipes[i].x + pipWidth < 0) 
		{
            int gapPosition = (rand() % 500) + 200; 
            pipes[i].x = 900;
            pipes[i].upY = gapPosition - pipHeight;
            pipes[i].downY = gapPosition + PIPE_GAP;
            pipes[i].passed = false;
        }
    }
}
```

##### 关于我之前对上下管道的疑问：

upY是处于屏幕上方的管道，暂且称为上管道，downY是处于屏幕下方的管道，暂且称为下管道

上管道的y坐标至少为`200 - 600 = -400`，意味着上管道从屏幕上方400像素处开始，只有底部200像素在屏幕内

下管道的y坐标至少为`200 + 250 = 450`，意味着下管道从屏幕450像素处开始，只有550在屏幕内





#### 金币随机位置出现

```c
#define COIN_WIDTH 32
#define COIN_HEIGHT 32
#define COIN_COUNT 3 //最大金币数量 
#define COIN_LEFT 200  //金币出现区域左边界
#define COIN_RIGHT 700  //金币出现区域右边界 
#define COIN_TOP 100 	//金币出现区域上边界 
#define COIN_BOTTOM 800 //金币出现区域下边界 
#define COIN_SPEED 2


//金币结构体
typedef struct{
	int x;
	int y;
	bool appear; //是否该显示 
} Coin; 

Coin coins[COIN_COUNT]; //金币数组 
int coinCount = 0; //当前金币数量 

//main函数内
int main()
{
    //金币初始化
	for (int i = 0; i < COIN_COUNT ;i++)
	{
		coins[i].appear = false;	
	} 
    if(gamepause == false)
    {
   			generateCoins();
			updateCoins();
			drawCoins();
    		//金币碰撞检测
			CoinCollision();
		
    }
}


//更改金币位置 
void updateCoins()
{
	for(int i = 0; i < COIN_COUNT; i++) {
        if(coins[i].appear) {
            coins[i].x -= COIN_SPEED; // 金币向左移动
    
            // 如果金币移出屏幕左侧，重置它
            if(coins[i].x + COIN_WIDTH < 0) {
                coins[i].appear = false;
                coinCount--;
            }
        }
    }
}

//生成金币 
void generateCoins()
{
	if(rand() % 100 < 20 && coinCount < COIN_COUNT)//随机决定是否生成新金币，20%的几率生成新金币
	{
		for(int i = 0; i < COIN_COUNT ;i++)
		{
			if(!coins[i].appear)
			{
				coins[i].x = COIN_LEFT + rand() % (COIN_RIGHT - COIN_LEFT);
				coins[i].y = COIN_TOP + rand() % (COIN_BOTTOM - COIN_TOP);
				coins[i].appear = true;
				coinCount++;
				break;	
			}	
		}	
	} 
}

//绘制金币
void drawCoins()
{
	for(int i = 0;i < COIN_COUNT ;i++)
	{
		if(coins[i].appear)
		{
			showCoins(coins[i].x,coins[i].y);	
		}	
	}	
} 


//检测金币碰撞
void CoinCollision()
{
	for(int i = 0; i< COIN_COUNT ; i++)
	{
		if(coins[i].appear && checkCollision(birdX,birdY,birdWidth,birdHeight,coins[i].x,coins[i].y,COIN_WIDTH,COIN_HEIGHT))
		{
			// 碰撞到金币，播放音效，增加分数等
            mciSendString("open sound/coins.mp3 alias coin", NULL, 0, NULL);
            mciSendString("play coin from 0", NULL, 0, NULL);
            coins[i].appear = false;
            coinCount--;
            // 这里可以增加分数	
		}	
	}	
} 
```



可以再加个分数的部分，我没加
